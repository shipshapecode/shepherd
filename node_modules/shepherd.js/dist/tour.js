/*! shepherd.js 12.0.0-alpha.3 */

import { Evented } from './evented.js';
import { a as SvelteComponent, i as init, s as safe_not_equal, b as svg_element, c as attr, d as insert, e as append, l as listen, n as noop, f as detach, g as binding_callbacks, S as Step } from './step-BimqmZcv.js';
import autoBind from './utils/auto-bind.js';
import { isUndefined, isFunction, isString, isHTMLElement } from './utils/type-check.js';
import { cleanupSteps } from './utils/cleanup.js';
import DataRequest from './utils/datarequest.js';
import { uuid, normalizePrefix } from './utils/general.js';
import { makeOverlayPath } from './utils/overlay-path.js';
import './floating-ui-DsWg7XIh.js';
import './utils/bind.js';

/* src/components/shepherd-modal.svelte generated by Svelte v3.59.2 */
function create_fragment(ctx) {
  let svg;
  let path;
  let svg_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", /*pathDefinition*/ctx[2]);
      attr(svg, "class", svg_class_value = `${/*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : ''} shepherd-modal-overlay-container`);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      /*svg_binding*/
      ctx[11](svg);
      if (!mounted) {
        dispose = listen(svg, "touchmove", /*_preventModalOverlayTouch*/ctx[3]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*pathDefinition*/4) {
        attr(path, "d", /*pathDefinition*/ctx[2]);
      }
      if (dirty & /*modalIsVisible*/2 && svg_class_value !== (svg_class_value = `${/*modalIsVisible*/ctx[1] ? 'shepherd-modal-is-visible' : ''} shepherd-modal-overlay-container`)) {
        attr(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) detach(svg);
      /*svg_binding*/
      ctx[11](null);
      mounted = false;
      dispose();
    }
  };
}
function _getScrollParent(element) {
  if (!element) {
    return null;
  }
  const isHtmlElement = element instanceof HTMLElement;
  const overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;
  const isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';
  if (isScrollable && element.scrollHeight >= element.clientHeight) {
    return element;
  }
  return _getScrollParent(element.parentElement);
}

/**
 * Get the top and left offset required to position the modal overlay cutout
 * when the target element is within an iframe
 * @param {HTMLElement} element The target element
 * @private
 */
function _getIframeOffset(element) {
  let offset = {
    top: 0,
    left: 0
  };
  if (!element) {
    return offset;
  }
  let targetWindow = element.ownerDocument.defaultView;
  while (targetWindow !== window.top) {
    var _targetWindow;
    const targetIframe = (_targetWindow = targetWindow) == null ? void 0 : _targetWindow.frameElement;
    if (targetIframe) {
      var _targetIframeRect$scr, _targetIframeRect$scr2;
      const targetIframeRect = targetIframe.getBoundingClientRect();
      offset.top += targetIframeRect.top + ((_targetIframeRect$scr = targetIframeRect.scrollTop) != null ? _targetIframeRect$scr : 0);
      offset.left += targetIframeRect.left + ((_targetIframeRect$scr2 = targetIframeRect.scrollLeft) != null ? _targetIframeRect$scr2 : 0);
    }
    targetWindow = targetWindow.parent;
  }
  return offset;
}

/**
 * Get the visible height of the target element relative to its scrollParent.
 * If there is no scroll parent, the height of the element is returned.
 *
 * @param {HTMLElement} element The target element
 * @param {HTMLElement} [scrollParent] The scrollable parent element
 * @returns {{y: number, height: number}}
 * @private
 */
function _getVisibleHeight(element, scrollParent) {
  const elementRect = element.getBoundingClientRect();
  let top = elementRect.y || elementRect.top;
  let bottom = elementRect.bottom || top + elementRect.height;
  if (scrollParent) {
    const scrollRect = scrollParent.getBoundingClientRect();
    const scrollTop = scrollRect.y || scrollRect.top;
    const scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;
    top = Math.max(top, scrollTop);
    bottom = Math.min(bottom, scrollBottom);
  }
  const height = Math.max(bottom - top, 0); // Default to 0 if height is negative
  return {
    y: top,
    height
  };
}
function instance($$self, $$props, $$invalidate) {
  let {
    element,
    openingProperties
  } = $$props;
  uuid();
  let modalIsVisible = false;
  let rafId = undefined;
  let pathDefinition;
  closeModalOpening();
  const getElement = () => element;
  function closeModalOpening() {
    $$invalidate(4, openingProperties = {
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      r: 0
    });
  }
  function hide() {
    $$invalidate(1, modalIsVisible = false);

    // Ensure we cleanup all event listeners when we hide the modal
    _cleanupStepEventListeners();
  }
  function positionModal(modalOverlayOpeningPadding = 0, modalOverlayOpeningRadius = 0, modalOverlayOpeningXOffset = 0, modalOverlayOpeningYOffset = 0, scrollParent, targetElement) {
    if (targetElement) {
      const {
        y,
        height
      } = _getVisibleHeight(targetElement, scrollParent);
      const {
        x,
        width,
        left
      } = targetElement.getBoundingClientRect();

      // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top
      $$invalidate(4, openingProperties = {
        width: width + modalOverlayOpeningPadding * 2,
        height: height + modalOverlayOpeningPadding * 2,
        x: (x || left) + modalOverlayOpeningXOffset - modalOverlayOpeningPadding,
        y: y + modalOverlayOpeningYOffset - modalOverlayOpeningPadding,
        r: modalOverlayOpeningRadius
      });
    } else {
      closeModalOpening();
    }
  }
  function setupForStep(step) {
    // Ensure we move listeners from the previous step, before we setup new ones
    _cleanupStepEventListeners();
    if (step.tour.options.useModalOverlay) {
      _styleForStep(step);
      show();
    } else {
      hide();
    }
  }
  function show() {
    $$invalidate(1, modalIsVisible = true);
  }
  const _preventModalBodyTouch = e => {
    e.preventDefault();
  };
  const _preventModalOverlayTouch = e => {
    e.stopPropagation();
  };

  /**
  * Add touchmove event listener
  * @private
  */
  function _addStepEventListeners() {
    // Prevents window from moving on touch.
    window.addEventListener('touchmove', _preventModalBodyTouch, {
      passive: false
    });
  }

  /**
  * Cancel the requestAnimationFrame loop and remove touchmove event listeners
  * @private
  */
  function _cleanupStepEventListeners() {
    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = undefined;
    }
    window.removeEventListener('touchmove', _preventModalBodyTouch, {
      passive: false
    });
  }

  /**
  * Style the modal for the step
  * @param {Step} step The step to style the opening for
  * @private
  */
  function _styleForStep(step) {
    const {
      modalOverlayOpeningPadding,
      modalOverlayOpeningRadius,
      modalOverlayOpeningXOffset = 0,
      modalOverlayOpeningYOffset = 0
    } = step.options;
    const iframeOffset = _getIframeOffset(step.target);
    const scrollParent = _getScrollParent(step.target);

    // Setup recursive function to call requestAnimationFrame to update the modal opening position
    const rafLoop = () => {
      rafId = undefined;
      positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, modalOverlayOpeningXOffset + iframeOffset.left, modalOverlayOpeningYOffset + iframeOffset.top, scrollParent, step.target);
      rafId = requestAnimationFrame(rafLoop);
    };
    rafLoop();
    _addStepEventListeners();
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
      element = $$value;
      $$invalidate(0, element);
    });
  }
  $$self.$$set = $$props => {
    if ('element' in $$props) $$invalidate(0, element = $$props.element);
    if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*openingProperties*/16) {
      $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));
    }
  };
  return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];
}
class Shepherd_modal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      element: 0,
      openingProperties: 4,
      getElement: 5,
      closeModalOpening: 6,
      hide: 7,
      positionModal: 8,
      setupForStep: 9,
      show: 10
    });
  }
  get getElement() {
    return this.$$.ctx[5];
  }
  get closeModalOpening() {
    return this.$$.ctx[6];
  }
  get hide() {
    return this.$$.ctx[7];
  }
  get positionModal() {
    return this.$$.ctx[8];
  }
  get setupForStep() {
    return this.$$.ctx[9];
  }
  get show() {
    return this.$$.ctx[10];
  }
}

const SHEPHERD_DEFAULT_API = 'https://shepherdpro.com';
const SHEPHERD_USER_ID = 'shepherdPro:userId';
class ShepherdPro extends Evented {
    init(apiKey, apiPath) {
        if (!apiKey) {
            throw new Error('Shepherd Pro: Missing required apiKey option.');
        }
        this.apiKey = apiKey;
        this.apiPath = apiPath ?? SHEPHERD_DEFAULT_API;
        if (this.apiKey) {
            this.dataRequester = new DataRequest(this.apiKey, this.apiPath);
            // Setup actor before first tour is loaded if none exists
            const shepherdProId = localStorage.getItem(SHEPHERD_USER_ID);
            if (!shepherdProId) {
                this.createNewActor();
            }
        }
    }
    async createNewActor() {
        if (!this.dataRequester)
            return;
        // Setup type returns an actor
        const response = (await this.dataRequester.sendEvents({
            data: {
                currentUserId: null,
                eventType: 'setup'
            }
        }));
        localStorage.setItem(SHEPHERD_USER_ID, String(response.actorId));
    }
}
/**
 * Class representing the site tour
 * @extends {Evented}
 */
class Tour extends Evented {
    constructor(options = {}) {
        super();
        this.trackedEvents = ['active', 'cancel', 'complete', 'show'];
        this.currentUserId = null;
        autoBind(this);
        const defaultTourOptions = {
            exitOnEsc: true,
            keyboardNavigation: true
        };
        this.options = Object.assign({}, defaultTourOptions, options);
        this.classPrefix = normalizePrefix(this.options.classPrefix);
        this.steps = [];
        this.addSteps(this.options.steps);
        // Pass these events onto the global Shepherd object
        const events = [
            'active',
            'cancel',
            'complete',
            'inactive',
            'show',
            'start'
        ];
        events.map((event) => {
            ((e) => {
                this.on(e, (opts) => {
                    opts = opts || {};
                    opts['tour'] = this;
                    Shepherd.trigger(e, opts);
                });
            })(event);
        });
        this._setTourID();
        const { apiKey, apiPath } = Shepherd;
        // If we have an API key, then setup Pro features
        if (apiKey && apiPath) {
            this.dataRequester = new DataRequest(apiKey, apiPath);
            const shepherdProId = localStorage.getItem('shepherdPro:userId');
            this.currentUserId = shepherdProId;
            this.trackedEvents.forEach((event) => this.on(event, (opts) => {
                const { tour } = opts;
                const { id, steps } = tour;
                let position;
                if (event !== 'active') {
                    const { step: currentStep } = opts;
                    if (currentStep) {
                        position =
                            steps.findIndex((step) => step.id === currentStep.id) + 1;
                    }
                }
                const data = {
                    currentUserId: this.currentUserId,
                    eventType: event,
                    journeyData: {
                        id,
                        currentStep: position,
                        numberOfSteps: steps.length,
                        tourOptions: tour.options
                    }
                };
                this.dataRequester?.sendEvents({ data });
            }));
        }
        return this;
    }
    /**
     * Adds a new step to the tour
     * @param options - An object containing step options or a Step instance
     * @param index - The optional index to insert the step at. If undefined, the step
     * is added to the end of the array.
     * @return The newly added step
     */
    addStep(options, index) {
        let step = options;
        if (!(step instanceof Step)) {
            step = new Step(this, step);
        }
        else {
            step.tour = this;
        }
        if (!isUndefined(index)) {
            this.steps.splice(index, 0, step);
        }
        else {
            this.steps.push(step);
        }
        return step;
    }
    /**
     * Add multiple steps to the tour
     * @param steps - The steps to add to the tour
     */
    addSteps(steps) {
        if (Array.isArray(steps)) {
            steps.forEach((step) => {
                this.addStep(step);
            });
        }
        return this;
    }
    /**
     * Go to the previous step in the tour
     */
    back() {
        const index = this.steps.indexOf(this.currentStep);
        this.show(index - 1, false);
    }
    /**
     * Calls _done() triggering the 'cancel' event
     * If `confirmCancel` is true, will show a window.confirm before cancelling
     * If `confirmCancel` is a function, will call it and wait for the return value,
     * and only cancel when the value returned is true
     */
    async cancel() {
        if (this.options.confirmCancel) {
            const cancelMessage = this.options.confirmCancelMessage ||
                'Are you sure you want to stop the tour?';
            let stopTour;
            if (isFunction(this.options.confirmCancel)) {
                stopTour = await this.options.confirmCancel();
            }
            else {
                stopTour = window.confirm(cancelMessage);
            }
            if (stopTour) {
                this._done('cancel');
            }
        }
        else {
            this._done('cancel');
        }
    }
    /**
     * Calls _done() triggering the `complete` event
     */
    complete() {
        this._done('complete');
    }
    /**
     * Gets the step from a given id
     * @param id - The id of the step to retrieve
     * @return The step corresponding to the `id`
     */
    getById(id) {
        return this.steps.find((step) => {
            return step.id === id;
        });
    }
    /**
     * Gets the current step
     */
    getCurrentStep() {
        return this.currentStep;
    }
    /**
     * Hide the current step
     */
    hide() {
        const currentStep = this.getCurrentStep();
        if (currentStep) {
            return currentStep.hide();
        }
    }
    /**
     * Check if the tour is active
     */
    isActive() {
        return Shepherd.activeTour === this;
    }
    /**
     * Go to the next step in the tour
     * If we are at the end, call `complete`
     */
    next() {
        const index = this.steps.indexOf(this.currentStep);
        if (index === this.steps.length - 1) {
            this.complete();
        }
        else {
            this.show(index + 1, true);
        }
    }
    /**
     * Removes the step from the tour
     * @param name - The id for the step to remove
     */
    removeStep(name) {
        const current = this.getCurrentStep();
        // Find the step, destroy it and remove it from this.steps
        this.steps.some((step, i) => {
            if (step.id === name) {
                if (step.isOpen()) {
                    step.hide();
                }
                step.destroy();
                this.steps.splice(i, 1);
                return true;
            }
        });
        if (current && current.id === name) {
            this.currentStep = undefined;
            // If we have steps left, show the first one, otherwise just cancel the tour
            this.steps.length ? this.show(0) : this.cancel();
        }
    }
    /**
     * Show a specific step in the tour
     * @param key - The key to look up the step by
     * @param forward - True if we are going forward, false if backward
     */
    show(key = 0, forward = true) {
        const step = isString(key) ? this.getById(key) : this.steps[key];
        if (step) {
            this._updateStateBeforeShow();
            const shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn();
            // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal
            if (shouldSkipStep) {
                this._skipStep(step, forward);
            }
            else {
                this.trigger('show', {
                    step,
                    previous: this.currentStep
                });
                this.currentStep = step;
                step.show();
            }
        }
    }
    /**
     * Start the tour
     */
    start() {
        this.trigger('start');
        // Save the focused element before the tour opens
        this.focusedElBeforeOpen = document.activeElement;
        this.currentStep = null;
        this.setupModal();
        this._setupActiveTour();
        this.next();
    }
    /**
     * Called whenever the tour is cancelled or completed, basically anytime we exit the tour
     * @param event The event name to trigger
     * @private
     */
    _done(event) {
        const index = this.steps.indexOf(this.currentStep);
        if (Array.isArray(this.steps)) {
            this.steps.forEach((step) => step.destroy());
        }
        cleanupSteps(this);
        this.trigger(event, { index });
        Shepherd.activeTour = null;
        this.trigger('inactive', { tour: this });
        if (this.modal) {
            this.modal.hide();
        }
        if (event === 'cancel' || event === 'complete') {
            if (this.modal) {
                const modalContainer = document.querySelector('.shepherd-modal-overlay-container');
                if (modalContainer) {
                    modalContainer.remove();
                }
            }
        }
        // Focus the element that was focused before the tour started
        if (isHTMLElement(this.focusedElBeforeOpen)) {
            this.focusedElBeforeOpen.focus();
        }
    }
    /**
     * Make this tour "active"
     */
    _setupActiveTour() {
        this.trigger('active', { tour: this });
        Shepherd.activeTour = this;
    }
    /**
     * setupModal create the modal container and instance
     */
    setupModal() {
        this.modal = new Shepherd_modal({
            target: this.options.modalContainer || document.body,
            props: {
                // @ts-expect-error TODO: investigate where styles comes from
                styles: this.styles
            }
        });
    }
    /**
     * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step
     * @param step - The step to skip
     * @param forward - True if we are going forward, false if backward
     * @private
     */
    _skipStep(step, forward) {
        const index = this.steps.indexOf(step);
        if (index === this.steps.length - 1) {
            this.complete();
        }
        else {
            const nextIndex = forward ? index + 1 : index - 1;
            this.show(nextIndex, forward);
        }
    }
    /**
     * Before showing, hide the current step and if the tour is not
     * already active, call `this._setupActiveTour`.
     * @private
     */
    _updateStateBeforeShow() {
        if (this.currentStep) {
            this.currentStep.hide();
        }
        if (!this.isActive()) {
            this._setupActiveTour();
        }
    }
    /**
     * Sets this.id to `${tourName}--${uuid}`
     * @private
     */
    _setTourID() {
        const tourName = this.options.tourName || 'tour';
        this.id = `${tourName}--${uuid()}`;
    }
}
const Shepherd = new ShepherdPro();

export { Shepherd, ShepherdPro, Tour };
//# sourceMappingURL=tour.js.map
